const Je = "host", Re = "queue/data", We = "queue/join", ge = "upload", Ze = "login", we = "config", Ke = "info", Ve = "runtime", Ye = "sleeptime", Qe = "heartbeat", Xe = "component_server", et = "reset", tt = "cancel", st = "app_id", Oe = "This application is currently busy. Please try again. ", M = "Connection errored out. ", I = "Could not resolve app config. ", nt = "Could not get space status. ", ot = "Could not get API info. ", ae = "Space metadata could not be loaded. ", it = "Invalid URL. A full URL path is required.", rt = "Not authorized to access this space. ", Te = "Invalid credentials. Could not login. ", at = "Login credentials are required to access this space.", ct = "File system access is only available in Node.js environments", Ae = "Root URL not found in client config", ut = "Error uploading file";
async function ye(e, s, t) {
  try {
    return (await (await fetch(`https://huggingface.co/api/spaces/${e}/jwt`, {
      headers: {
        Authorization: `Bearer ${s}`,
        ...t ? { Cookie: t } : {}
      }
    })).json()).token || !1;
  } catch {
    return !1;
  }
}
function lt(e) {
  let s = {};
  return e.forEach(({ api_name: t, id: n }) => {
    t && (s[t] = n);
  }), s;
}
async function pt(e) {
  const s = this.options.token ? { Authorization: `Bearer ${this.options.token}` } : {};
  s["Content-Type"] = "application/json", typeof window < "u" && window?.gradio_config?.current_page && (e = e.substring(0, e.lastIndexOf("/")));
  let t = De(
    e,
    this.deep_link ? we + "?deep_link=" + this.deep_link : we
  );
  const n = await this.fetch(t, {
    headers: s,
    credentials: "include"
  }), o = await dt(n, !!this.options.auth);
  return typeof window < "u" && window?.BUILD_MODE === "dev" && (o.root = e || o.root), o;
}
async function dt(e, s) {
  if (e?.status === 401 && !s) {
    const n = (await e.json())?.detail?.auth_message;
    throw new Error(n || at);
  } else if (e?.status === 401 && s)
    throw new Error(Te);
  if (e?.status === 200) {
    let t = await e.json();
    return t.dependencies?.forEach((n, o) => {
      n.id === void 0 && (n.id = o);
    }), t;
  } else if (e?.status === 401)
    throw new Error(rt);
  throw new Error(I);
}
async function ht() {
  const { http_protocol: e, host: s } = await ue(
    this.app_reference,
    this.options.token
  );
  try {
    if (this.options.auth) {
      const t = await xe(
        e,
        s,
        this.options.auth,
        this.fetch,
        this.options.token
      );
      t && this.set_cookies(t);
    }
  } catch (t) {
    throw Error(t.message);
  }
}
async function xe(e, s, t, n, o) {
  const r = new FormData();
  r.append("username", t?.[0]), r.append("password", t?.[1]);
  let i = {};
  o && (i.Authorization = `Bearer ${o}`);
  const a = await n(`${e}//${s}/${Ze}`, {
    headers: i,
    method: "POST",
    body: r,
    credentials: "include"
  });
  if (a.status === 200)
    return a.headers.get("set-cookie");
  throw a.status === 401 ? new Error(Te) : new Error(ae);
}
function ie(e) {
  if (e.startsWith("http")) {
    const { protocol: s, host: t, pathname: n } = new URL(e);
    return {
      ws_protocol: s === "https:" ? "wss" : "ws",
      http_protocol: s,
      host: t + (n !== "/" ? n : "")
    };
  }
  return {
    ws_protocol: "wss",
    http_protocol: "https:",
    host: new URL(e).host
  };
}
const Ce = (e) => {
  let s = [];
  return e.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/).forEach((n) => {
    const [o, r] = n.split(";")[0].split("=");
    o && r && s.push(`${o.trim()}=${r.trim()}`);
  }), s;
}, ce = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/, ft = /.*hf\.space\/{0,1}.*$/;
async function ue(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  const n = e.trim().replace(/\/$/, "");
  if (ce.test(n))
    try {
      const r = (await (await fetch(
        `https://huggingface.co/api/spaces/${n}/${Je}`,
        { headers: t }
      )).json()).host;
      return {
        space_id: e,
        ...ie(r)
      };
    } catch {
      throw new Error(ae);
    }
  if (ft.test(n)) {
    const { ws_protocol: o, http_protocol: r, host: i } = ie(n);
    return {
      space_id: i.split("/")[0].replace(".hf.space", ""),
      ws_protocol: o,
      http_protocol: r,
      host: i
    };
  }
  return {
    space_id: !1,
    ...ie(n)
  };
}
const De = (...e) => {
  try {
    return e.reduce((s, t) => (s = s.replace(/\/+$/, ""), t = t.replace(/^\/+/, ""), new URL(t, s + "/").toString()));
  } catch {
    throw new Error(it);
  }
};
function _t(e, s, t) {
  const n = {
    named_endpoints: {},
    unnamed_endpoints: {}
  };
  return Object.keys(e).forEach((o) => {
    (o === "named_endpoints" || o === "unnamed_endpoints") && (n[o] = {}, Object.entries(e[o]).forEach(
      ([r, { parameters: i, returns: a }]) => {
        const u = s.dependencies.find(
          (c) => c.api_name === r || c.api_name === r.replace("/", "")
        )?.id || t[r.replace("/", "")] || -1, l = u !== -1 ? s.dependencies.find((c) => c.id == u)?.types : { generator: !1, cancel: !1 };
        if (u !== -1 && s.dependencies.find((c) => c.id == u)?.inputs?.length !== i.length) {
          const c = s.dependencies.find((m) => m.id == u).inputs.map(
            (m) => s.components.find((w) => w.id === m)?.type
          );
          try {
            c.forEach((m, w) => {
              if (m === "state") {
                const D = {
                  component: "state",
                  example: null,
                  parameter_default: null,
                  parameter_has_default: !0,
                  parameter_name: null,
                  hidden: !0
                };
                i.splice(w, 0, D);
              }
            });
          } catch (m) {
            console.error(m);
          }
        }
        const p = (c, m, w, D) => ({
          ...c,
          description: gt(c?.type, w),
          type: mt(c?.type, m, w, D) || ""
        });
        n[o][r] = {
          parameters: i.map(
            (c) => p(c, c?.component, c?.serializer, "parameter")
          ),
          returns: a.map(
            (c) => p(c, c?.component, c?.serializer, "return")
          ),
          type: l
        };
      }
    ));
  }), n;
}
function mt(e, s, t, n) {
  if (s === "Api") return e.type;
  switch (e?.type) {
    case "string":
      return "string";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
  }
  if (t === "JSONSerializable" || t === "StringSerializable")
    return "any";
  if (t === "ListStringSerializable")
    return "string[]";
  if (s === "Image")
    return n === "parameter" ? "Blob | File | Buffer" : "string";
  if (t === "FileSerializable")
    return e?.type === "array" ? n === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : n === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
  if (t === "GallerySerializable")
    return n === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
}
function gt(e, s) {
  return s === "GallerySerializable" ? "array of [file, label] tuples" : s === "ListStringSerializable" ? "array of strings" : s === "FileSerializable" ? "array of files or single file" : e?.description;
}
function be(e, s) {
  switch (e.msg) {
    case "send_data":
      return { type: "data" };
    case "send_hash":
      return { type: "hash" };
    case "queue_full":
      return {
        type: "update",
        status: {
          queue: !0,
          message: Oe,
          stage: "error",
          code: e.code,
          success: e.success
        }
      };
    case "heartbeat":
      return {
        type: "heartbeat"
      };
    case "unexpected_error":
      return {
        type: "unexpected_error",
        status: {
          queue: !0,
          message: e.message,
          session_not_found: e.session_not_found,
          stage: "error",
          success: !1
        }
      };
    case "broken_connection":
      return {
        type: "broken_connection",
        status: {
          queue: !0,
          message: e.message,
          stage: "error",
          success: !1
        }
      };
    case "estimation":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: s || "pending",
          code: e.code,
          size: e.queue_size,
          position: e.rank,
          eta: e.rank_eta,
          success: e.success
        }
      };
    case "progress":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          progress_data: e.progress_data,
          success: e.success
        }
      };
    case "log":
      return { type: "log", data: e };
    case "process_generating":
      return {
        type: "generating",
        status: {
          queue: !0,
          message: e.success ? null : e.output.error,
          stage: e.success ? "generating" : "error",
          code: e.code,
          progress_data: e.progress_data,
          eta: e.average_duration,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_streaming":
      return {
        type: "streaming",
        status: {
          queue: !0,
          message: e.output.error,
          stage: "streaming",
          time_limit: e.time_limit,
          code: e.code,
          progress_data: e.progress_data,
          eta: e.eta
        },
        data: e.output
      };
    case "process_completed":
      return "error" in e.output ? {
        type: "update",
        status: {
          queue: !0,
          title: e.output.title ?? "Error",
          message: e.output.error ?? "An error occurred",
          visible: e.output.visible,
          duration: e.output.duration,
          stage: "error",
          code: e.code,
          success: e.success
        }
      } : {
        type: "complete",
        status: {
          queue: !0,
          message: e.success ? void 0 : e.output.error,
          stage: e.success ? "complete" : "error",
          code: e.code,
          progress_data: e.progress_data,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_starts":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          size: e.rank,
          position: 0,
          success: e.success,
          eta: e.eta
        },
        original_msg: "process_starts"
      };
  }
  return { type: "none", status: { stage: "error", queue: !0 } };
}
const wt = (e = [], s) => {
  const t = s ? s.parameters : [];
  if (Array.isArray(e))
    return s && t.length > 0 && e.length > t.length && console.warn("Too many arguments provided for the endpoint."), e;
  const n = [], o = Object.keys(e);
  return t.forEach((r, i) => {
    if (e.hasOwnProperty(r.parameter_name))
      n[i] = e[r.parameter_name];
    else if (r.parameter_has_default)
      n[i] = r.parameter_default;
    else
      throw new Error(
        `No value provided for required parameter: ${r.parameter_name}`
      );
  }), o.forEach((r) => {
    if (!t.some((i) => i.parameter_name === r))
      throw new Error(
        `Parameter \`${r}\` is not a valid keyword argument. Please refer to the API for usage.`
      );
  }), n.forEach((r, i) => {
    if (r === void 0 && !t[i].parameter_has_default)
      throw new Error(
        `No value provided for required parameter: ${t[i].parameter_name}`
      );
  }), n;
};
async function yt() {
  if (this.api_info) return this.api_info;
  const { token: e } = this.options, { config: s } = this, t = { "Content-Type": "application/json" };
  if (e && (t.Authorization = `Bearer ${e}`), !!s)
    try {
      let n, o;
      if (typeof window < "u" && window.gradio_api_info)
        o = window.gradio_api_info;
      else {
        const r = De(s.root, this.api_prefix, Ke);
        if (n = await this.fetch(r, {
          headers: t,
          credentials: "include"
        }), !n.ok)
          throw new Error(M);
        o = await n.json();
      }
      return "api" in o && (o = o.api), o.named_endpoints["/predict"] && !o.unnamed_endpoints[0] && (o.unnamed_endpoints[0] = o.named_endpoints["/predict"]), _t(o, s, this.api_map);
    } catch (n) {
      throw new Error("Could not get API info. " + n.message);
    }
}
async function bt(e, s, t) {
  const n = {};
  this?.options?.token && (n.Authorization = `Bearer ${this.options.token}`);
  const o = 1e3, r = [];
  let i;
  for (let a = 0; a < s.length; a += o) {
    const u = s.slice(a, a + o), l = new FormData();
    u.forEach((c) => {
      l.append("files", c);
    });
    try {
      const c = t ? `${e}${this.api_prefix}/${ge}?upload_id=${t}` : `${e}${this.api_prefix}/${ge}`;
      i = await this.fetch(c, {
        method: "POST",
        body: l,
        headers: n,
        credentials: "include"
      });
    } catch (c) {
      throw new Error(M + c.message);
    }
    if (!i.ok) {
      const c = await i.text();
      return { error: `HTTP ${i.status}: ${c}` };
    }
    const p = await i.json();
    p && r.push(...p);
  }
  return { files: r };
}
const vt = {
  radix: 1e3,
  unit: ["b", "kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"]
}, Et = {
  radix: 1024,
  unit: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"]
}, St = {
  radix: 1024,
  unit: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"]
}, ve = {
  si: vt,
  iec: Et,
  jedec: St
};
function $t(e, s = 1, t = "jedec") {
  e = Math.abs(e);
  const { radix: n, unit: o } = ve[t] || ve.jedec;
  let r = 0;
  for (; e >= n; )
    e /= n, ++r;
  return `${e.toFixed(s)} ${o[r]}`;
}
async function kt(e, s, t, n) {
  let o = (Array.isArray(e) ? e : [e]).map(
    (i) => i.blob
  );
  const r = o.filter(
    (i) => i.size > (n ?? 1 / 0)
  );
  if (r.length)
    throw new Error(
      `File(s) exceed the maximum allowed size of ${$t(n || 1 / 0)}: ${r.map((i) => `"${i.name}"`).join(", ")}`
    );
  return await Promise.all(
    await this.upload_files(s, o, t).then(
      async (i) => {
        if (i.error)
          throw new Error(i.error);
        return i.files ? i.files.map((a, u) => new Y({
          ...e[u],
          path: a,
          url: `${s}${this.api_prefix}/file=${a}`
        })) : [];
      }
    )
  );
}
async function Xt(e, s) {
  return e.map(
    (t) => new Y({
      path: t.name,
      orig_name: t.name,
      blob: t,
      size: t.size,
      mime_type: t.type,
      is_stream: s
    })
  );
}
class Y {
  path;
  url;
  orig_name;
  size;
  blob;
  is_stream;
  mime_type;
  alt_text;
  b64;
  meta = { _type: "gradio.FileData" };
  constructor({
    path: s,
    url: t,
    orig_name: n,
    size: o,
    blob: r,
    is_stream: i,
    mime_type: a,
    alt_text: u,
    b64: l
  }) {
    this.path = s, this.url = t, this.orig_name = n, this.size = o, this.blob = t ? void 0 : r, this.is_stream = i, this.mime_type = a, this.alt_text = u, this.b64 = l;
  }
}
class Ne {
  type;
  command;
  meta;
  fileData;
  constructor(s, t) {
    this.type = "command", this.command = s, this.meta = t;
  }
}
const Rt = typeof process < "u" && process.versions && process.versions.node;
function Ee(e, s, t) {
  for (; t.length > 1; ) {
    const o = t.shift();
    if (typeof o == "string" || typeof o == "number")
      e = e[o];
    else
      throw new Error("Invalid key type");
  }
  const n = t.shift();
  if (typeof n == "string" || typeof n == "number")
    e[n] = s;
  else
    throw new Error("Invalid key type");
}
async function re(e, s = void 0, t = [], n = !1, o = void 0) {
  if (Array.isArray(e)) {
    let r = [];
    return await Promise.all(
      e.map(async (i, a) => {
        let u = t.slice();
        u.push(String(a));
        const l = await re(
          e[a],
          n ? o?.parameters[a]?.component || void 0 : s,
          u,
          !1,
          o
        );
        r = r.concat(l);
      })
    ), r;
  } else {
    if (globalThis.Buffer && e instanceof globalThis.Buffer || e instanceof Blob)
      return [
        {
          path: t,
          blob: new Blob([e]),
          type: s
        }
      ];
    if (typeof e == "object" && e !== null) {
      let r = [];
      for (const i of Object.keys(e)) {
        const a = [...t, i], u = e[i];
        r = r.concat(
          await re(
            u,
            void 0,
            a,
            !1,
            o
          )
        );
      }
      return r;
    }
  }
  return [];
}
function Ot(e, s) {
  let t = s?.dependencies?.find((n) => n.id == e)?.queue;
  return t != null ? !t : !s.enable_queue;
}
function Tt(e, s) {
  return new Promise((t, n) => {
    const o = new MessageChannel();
    o.port1.onmessage = (({ data: r }) => {
      o.port1.close(), t(r);
    }), window.parent.postMessage(e, s, [o.port2]);
  });
}
function es(e) {
  if (typeof e == "string") {
    if (e.startsWith("http://") || e.startsWith("https://"))
      return {
        path: e,
        url: e,
        orig_name: e.split("/").pop() ?? "unknown",
        meta: { _type: "gradio.FileData" }
      };
    if (Rt)
      return new Ne("upload_file", {
        path: e,
        name: e,
        orig_path: e
      });
  } else {
    if (typeof File < "u" && e instanceof File)
      return new Blob([e]);
    if (e instanceof Buffer)
      return new Blob([e]);
    if (e instanceof Blob)
      return e;
  }
  throw new Error(
    "Invalid input: must be a URL, File, Blob, or Buffer object."
  );
}
function K(e, s, t, n, o = !1) {
  if (n === "input" && !o)
    throw new Error("Invalid code path. Cannot skip state inputs for input.");
  if (n === "output" && o)
    return e;
  let r = [], i = 0;
  const a = n === "input" ? s.inputs : s.outputs;
  for (let u = 0; u < a.length; u++) {
    const l = a[u];
    if (t.find((c) => c.id === l)?.type === "state") {
      if (o)
        if (e.length === a.length) {
          const c = e[i];
          r.push(c), i++;
        } else
          r.push(null);
      else {
        i++;
        continue;
      }
      continue;
    } else {
      const c = e[i];
      r.push(c), i++;
    }
  }
  return r;
}
async function At(e, s, t) {
  const n = this;
  await xt(n, s);
  const o = await re(
    s,
    void 0,
    [],
    !0,
    t
  );
  return (await Promise.all(
    o.map(async ({ path: i, blob: a, type: u }) => {
      if (!a) return { path: i, type: u };
      const l = await n.upload_files(e, [a]), p = l.files && l.files[0];
      return {
        path: i,
        file_url: p,
        type: u,
        name: typeof File < "u" && a instanceof File ? a?.name : void 0
      };
    })
  )).forEach(({ path: i, file_url: a, type: u, name: l }) => {
    if (u === "Gallery")
      Ee(s, a, i);
    else if (a) {
      const p = new Y({ path: a, orig_name: l });
      Ee(s, p, i);
    }
  }), s;
}
async function xt(e, s) {
  if (!(e.config?.root || e.config?.root_url))
    throw new Error(Ae);
  await Le(e, s);
}
async function Le(e, s, t = []) {
  for (const n in s)
    s[n] instanceof Ne ? await Ct(e, s, n) : typeof s[n] == "object" && s[n] !== null && await Le(e, s[n], [...t, n]);
}
async function Ct(e, s, t) {
  let n = s[t];
  const o = e.config?.root || e.config?.root_url;
  if (!o)
    throw new Error(Ae);
  try {
    let r, i;
    if (typeof process < "u" && process.versions && process.versions.node) {
      const p = await import("./__vite-browser-external-DYxpcVy9.js");
      i = (await import("./__vite-browser-external-DYxpcVy9.js")).resolve(process.cwd(), n.meta.path), r = await p.readFile(i);
    } else
      throw new Error(ct);
    const a = new Blob([r], {
      type: "application/octet-stream"
    }), u = await e.upload_files(o, [a]), l = u.files && u.files[0];
    if (l) {
      const p = new Y({
        path: l,
        orig_name: n.meta.name || ""
      });
      s[t] = p;
    }
  } catch (r) {
    console.error(ut, r);
  }
}
async function Dt(e, s, t) {
  const n = { "Content-Type": "application/json" };
  this.options.token && (n.Authorization = `Bearer ${this.options.token}`);
  try {
    var o = await this.fetch(e, {
      method: "POST",
      body: JSON.stringify(s),
      headers: { ...n, ...t },
      credentials: "include"
    });
  } catch {
    return [{ error: M }, 500];
  }
  let r, i;
  try {
    r = await o.json(), i = o.status;
  } catch (a) {
    r = { error: `Could not parse server response: ${a}` }, i = 500;
  }
  return [r, i];
}
async function Nt(e, s = {}) {
  let t = !1, n = !1;
  if (!this.config)
    throw new Error("Could not resolve app config");
  if (typeof e == "number")
    this.config.dependencies.find((o) => o.id == e);
  else {
    const o = e.replace(/^\//, "");
    this.config.dependencies.find(
      (r) => r.id == this.api_map[o]
    );
  }
  return new Promise(async (o, r) => {
    const i = this.submit(e, s, null, null, !0);
    let a;
    for await (const u of i)
      u.type === "data" && (n && o(a), t = !0, a = u), u.type === "status" && (u.stage === "error" && r(u), u.stage === "complete" && (n = !0, t && o(a)));
  });
}
async function G(e, s, t) {
  let n = s === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${e}` : `https://huggingface.co/api/spaces/${e}`, o, r;
  try {
    if (o = await fetch(n), r = o.status, r !== 200)
      throw new Error();
    o = await o.json();
  } catch {
    t({
      status: "error",
      load_status: "error",
      message: nt,
      detail: "NOT_FOUND"
    });
    return;
  }
  if (!o || r !== 200) return;
  const {
    runtime: { stage: i },
    id: a
  } = o;
  switch (i) {
    case "STOPPED":
    case "SLEEPING":
      t({
        status: "sleeping",
        load_status: "pending",
        message: "Space is asleep. Waking it up...",
        detail: i
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    case "PAUSED":
      t({
        status: "paused",
        load_status: "error",
        message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
        detail: i,
        discussions_enabled: await Se(a)
      });
      break;
    case "RUNNING":
    case "RUNNING_BUILDING":
      t({
        status: "running",
        load_status: "complete",
        message: "Space is running.",
        detail: i
      });
      break;
    case "BUILDING":
      t({
        status: "building",
        load_status: "pending",
        message: "Space is building...",
        detail: i
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    case "APP_STARTING":
      t({
        status: "starting",
        load_status: "pending",
        message: "Space is starting...",
        detail: i
      }), setTimeout(() => {
        G(e, s, t);
      }, 1e3);
      break;
    default:
      t({
        status: "space_error",
        load_status: "error",
        message: "This space is experiencing an issue.",
        detail: i,
        discussions_enabled: await Se(a)
      });
      break;
  }
}
const Pe = async (e, s) => {
  let t = 0;
  const n = 12, o = 5e3;
  return new Promise((r) => {
    G(
      e,
      ce.test(e) ? "space_name" : "subdomain",
      (i) => {
        s(i), i.status === "running" || i.status === "error" || i.status === "paused" || i.status === "space_error" ? r() : (i.status === "sleeping" || i.status === "building") && (t < n ? (t++, setTimeout(() => {
          Pe(e, s).then(r);
        }, o)) : r());
      }
    );
  });
}, Lt = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
async function Se(e) {
  try {
    const s = await fetch(
      `https://huggingface.co/api/spaces/${e}/discussions`,
      {
        method: "HEAD"
      }
    ), t = s.headers.get("x-error-message");
    return !(!s.ok || t && Lt.test(t));
  } catch {
    return !1;
  }
}
async function Pt(e, s) {
  const t = {};
  s && (t.Authorization = `Bearer ${s}`);
  try {
    const n = await fetch(
      `https://huggingface.co/api/spaces/${e}/${Ve}`,
      { headers: t }
    );
    if (n.status !== 200)
      throw new Error("Space hardware could not be obtained.");
    const { hardware: o } = await n.json();
    return o.current;
  } catch (n) {
    throw new Error(n.message);
  }
}
async function It(e, s, t) {
  const n = {};
  t && (n.Authorization = `Bearer ${t}`);
  const o = {
    seconds: s
  };
  try {
    const r = await fetch(
      `https://huggingface.co/api/spaces/${e}/${Ye}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", ...n },
        body: JSON.stringify(o)
      }
    );
    if (r.status !== 200)
      throw new Error(
        "Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."
      );
    return await r.json();
  } catch (r) {
    throw new Error(r.message);
  }
}
const $e = [
  "cpu-basic",
  "cpu-upgrade",
  "cpu-xl",
  "t4-small",
  "t4-medium",
  "a10g-small",
  "a10g-large",
  "a10g-largex2",
  "a10g-largex4",
  "a100-large",
  "zero-a10g",
  "h100",
  "h100x8"
];
async function jt(e, s) {
  const { token: t, private: n, hardware: o, timeout: r, auth: i } = s;
  if (o && !$e.includes(o))
    throw new Error(
      `Invalid hardware type provided. Valid types are: ${$e.map((g) => `"${g}"`).join(",")}.`
    );
  const { http_protocol: a, host: u } = await ue(e, t);
  let l = null;
  if (i) {
    const g = await xe(
      a,
      u,
      i,
      fetch
    );
    g && (l = Ce(g));
  }
  const p = {
    Authorization: `Bearer ${t}`,
    "Content-Type": "application/json",
    ...l ? { Cookie: l.join("; ") } : {}
  }, c = (await (await fetch("https://huggingface.co/api/whoami-v2", {
    headers: p
  })).json()).name, m = e.split("/")[1], w = {
    repository: `${c}/${m}`
  };
  n && (w.private = !0);
  let D;
  try {
    o || (D = await Pt(e, t));
  } catch (g) {
    throw Error(ae + g.message);
  }
  const f = o || D || "cpu-basic";
  w.hardware = f;
  try {
    const g = await fetch(
      `https://huggingface.co/api/spaces/${e}/duplicate`,
      {
        method: "POST",
        headers: p,
        body: JSON.stringify(w)
      }
    );
    if (g.status === 409)
      try {
        return await V.connect(`${c}/${m}`, s);
      } catch (q) {
        throw console.error("Failed to connect Client instance:", q), q;
      }
    else if (g.status !== 200)
      throw new Error(g.statusText);
    const H = await g.json();
    return await It(`${c}/${m}`, r || 300, t), await V.connect(
      Ut(H.url),
      s
    );
  } catch (g) {
    throw new Error(g);
  }
}
function Ut(e) {
  const s = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/, t = e.match(s);
  if (t)
    return t[1];
}
class qt extends TransformStream {
  #e = "";
  /** Constructs a new instance. */
  constructor(s = { allowCR: !1 }) {
    super({
      transform: (t, n) => {
        for (t = this.#e + t; ; ) {
          const o = t.indexOf(`
`), r = s.allowCR ? t.indexOf("\r") : -1;
          if (r !== -1 && r !== t.length - 1 && (o === -1 || o - 1 > r)) {
            n.enqueue(t.slice(0, r)), t = t.slice(r + 1);
            continue;
          }
          if (o === -1)
            break;
          const i = t[o - 1] === "\r" ? o - 1 : o;
          n.enqueue(t.slice(0, i)), t = t.slice(o + 1);
        }
        this.#e = t;
      },
      flush: (t) => {
        if (this.#e === "")
          return;
        const n = s.allowCR && this.#e.endsWith("\r") ? this.#e.slice(0, -1) : this.#e;
        t.enqueue(n);
      }
    });
  }
}
function zt(e) {
  let s = new TextDecoderStream(), t = new qt({ allowCR: !0 });
  return e.pipeThrough(s).pipeThrough(t);
}
function Bt(e) {
  let t = /[:]\s*/.exec(e), n = t && t.index;
  if (n)
    return [
      e.substring(0, n),
      e.substring(n + t[0].length)
    ];
}
function ke(e, s, t) {
  e.get(s) || e.set(s, t);
}
async function* Ft(e, s) {
  if (!e.body)
    return;
  let t = zt(e.body), n, o = t.getReader(), r;
  for (; ; ) {
    if (s && s.aborted)
      return o.cancel();
    if (n = await o.read(), n.done)
      return;
    if (!n.value) {
      r && (yield r), r = void 0;
      continue;
    }
    let [i, a] = Bt(n.value) || [];
    i === "data" ? (r ||= {}, r[i] = r[i] ? r[i] + `
` + a : a) : i === "event" ? (r ||= {}, r[i] = a) : i === "id" ? (r ||= {}, r[i] = String(+a) === a ? +a : a) : i === "retry" && (r ||= {}, r[i] = +a || void 0);
  }
}
async function Gt(e, s) {
  let t = new Request(e, s);
  ke(t.headers, "Accept", "text/event-stream"), ke(t.headers, "Content-Type", "application/json");
  let n = await fetch(t);
  if (!n.ok)
    throw n;
  return Ft(n, t.signal);
}
async function Mt() {
  let {
    event_callbacks: e,
    unclosed_events: s,
    pending_stream_messages: t,
    stream_status: n,
    config: o,
    jwt: r
  } = this;
  const i = this;
  if (!o)
    throw new Error("Could not resolve app config");
  n.open = !0;
  let a = null, u = new URLSearchParams({
    session_hash: this.session_hash
  }).toString(), l = new URL(`${o.root}${this.api_prefix}/${Re}?${u}`);
  if (r && l.searchParams.set("__sign", r), a = this.stream(l), !a) {
    console.warn("Cannot connect to SSE endpoint: " + l.toString());
    return;
  }
  a.onmessage = async function(p) {
    let c = JSON.parse(p.data);
    if (c.msg === "close_stream") {
      le(n, i.abort_controller);
      return;
    }
    const m = c.event_id;
    if (!m)
      await Promise.all(
        Object.keys(e).map(
          (w) => e[w](c)
        )
      );
    else if (e[m] && o) {
      c.msg === "process_completed" && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(
        o.protocol
      ) && s.delete(m);
      let w = e[m];
      typeof window < "u" && typeof document < "u" ? setTimeout(w, 0, c) : w(c);
    } else
      t[m] || (t[m] = []), t[m].push(c);
  }, a.onerror = async function(p) {
    console.error(p), await Promise.all(
      Object.keys(e).map(
        (c) => e[c]({
          msg: "broken_connection",
          message: M
        })
      )
    );
  };
}
function le(e, s) {
  e && (e.open = !1, s?.abort());
}
function Ht(e, s, t) {
  !e[s] ? (e[s] = [], t.data.forEach((o, r) => {
    e[s][r] = o;
  })) : t.data.forEach((o, r) => {
    let i = Jt(e[s][r], o);
    e[s][r] = i, t.data[r] = i;
  });
}
function Jt(e, s) {
  return s.forEach(([t, n, o]) => {
    e = Wt(e, n, t, o);
  }), e;
}
function Wt(e, s, t, n) {
  if (s.length === 0) {
    if (t === "replace")
      return n;
    if (t === "append")
      return e + n;
    throw new Error(`Unsupported action: ${t}`);
  }
  let o = e;
  for (let i = 0; i < s.length - 1; i++)
    o = o[s[i]];
  const r = s[s.length - 1];
  switch (t) {
    case "replace":
      o[r] = n;
      break;
    case "append":
      o[r] += n;
      break;
    case "add":
      Array.isArray(o) ? o.splice(Number(r), 0, n) : o[r] = n;
      break;
    case "delete":
      Array.isArray(o) ? o.splice(Number(r), 1) : delete o[r];
      break;
    default:
      throw new Error(`Unknown action: ${t}`);
  }
  return e;
}
function Zt(e, s = {}) {
  const t = {
    close: () => {
      console.warn("Method not implemented.");
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    url: e.toString(),
    withCredentials: !1,
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    addEventListener: () => {
      throw new Error("Method not implemented.");
    },
    dispatchEvent: () => {
      throw new Error("Method not implemented.");
    },
    removeEventListener: () => {
      throw new Error("Method not implemented.");
    }
  };
  return Gt(e, s).then(async (n) => {
    t.readyState = t.OPEN;
    try {
      for await (const o of n)
        t.onmessage && t.onmessage(o);
      t.readyState = t.CLOSED;
    } catch (o) {
      t.onerror && t.onerror(o), t.readyState = t.CLOSED;
    }
  }).catch((n) => {
    console.error(n), t.onerror && t.onerror(n), t.readyState = t.CLOSED;
  }), t;
}
function Kt(e, s = {}, t, n, o, r) {
  try {
    let i = function(h) {
      (o || qe[h.type]) && p(h);
    }, a = function() {
      for (Ge = !0; F.length > 0; )
        F.shift()({
          value: void 0,
          done: !0
        });
    }, u = function(h) {
      F.length > 0 ? F.shift()(h) : ne.push(h);
    }, l = function(h) {
      u(Vt(h)), a();
    }, p = function(h) {
      u({ value: h, done: !1 });
    }, c = function() {
      return ne.length > 0 ? Promise.resolve(ne.shift()) : new Promise((h) => F.push(h));
    };
    const { token: m } = this.options, {
      fetch: w,
      app_reference: D,
      config: f,
      session_hash: g,
      api_info: H,
      api_map: q,
      stream_status: Q,
      pending_stream_messages: X,
      pending_diff_streams: ee,
      event_callbacks: te,
      unclosed_events: Ie,
      post_data: se,
      options: J,
      api_prefix: R
    } = this, pe = r || { "x-gradio-user": "api" }, je = this;
    if (!H) throw new Error("No API found");
    if (!f) throw new Error("Could not resolve app config");
    let { fn_index: d, endpoint_info: de, dependency: z } = Yt(
      H,
      e,
      q,
      f
    ), Ue = wt(s, de), j, O = f.protocol ?? "ws";
    if (O === "ws")
      throw new Error("WebSocket protocol is not supported in this version");
    let U = "", Qt = () => U;
    const _ = typeof e == "number" ? "/predict" : e;
    let W, b = null, T = !1, he = {}, B = typeof window < "u" && typeof document < "u" ? new URLSearchParams(window.location.search).toString() : "";
    const qe = J?.events?.reduce(
      (h, k) => (h[k] = !0, h),
      {}
    ) || {};
    async function ze() {
      let h = {}, k = {};
      h = { event_id: b }, k = { event_id: b, session_hash: g, fn_index: d };
      try {
        if (!f)
          throw new Error("Could not resolve app config");
        "event_id" in k && await w(`${f.root}${R}/${tt}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(k)
        }), await w(`${f.root}${R}/${et}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(h)
        });
      } catch {
        console.warn(
          "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
        );
      }
    }
    const Be = async (h) => {
      await this._resolve_heartbeat(h);
    };
    async function fe(h) {
      if (!f) return;
      let k = h.render_id;
      f.components = [
        ...f.components.filter((v) => v.props.rendered_in !== k),
        ...h.components
      ], f.dependencies = [
        ...f.dependencies.filter((v) => v.rendered_in !== k),
        ...h.dependencies
      ];
      const Z = f.components.some((v) => v.type === "state"), y = f.dependencies.some(
        (v) => v.targets.some((N) => N[1] === "unload")
      );
      f.connect_heartbeat = Z || y, await Be(f), i({
        type: "render",
        data: h,
        endpoint: _,
        fn_index: d
      });
    }
    const Fe = this.handle_blob(
      f.root,
      Ue,
      de
    ).then(async (h) => {
      if (W = {
        data: K(
          h,
          z,
          f.components,
          "input",
          !0
        ) || [],
        event_data: t,
        fn_index: d,
        trigger_id: n
      }, Ot(d, f))
        i({
          type: "status",
          endpoint: _,
          stage: "pending",
          queue: !1,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        }), se(
          `${f.root}${R}/run${_.startsWith("/") ? _ : `/${_}`}${B ? "?" + B : ""}`,
          {
            ...W,
            session_hash: g
          },
          pe
        ).then(async ([y, v]) => {
          const N = y.data;
          v == 200 ? (i({
            type: "data",
            endpoint: _,
            fn_index: d,
            data: K(
              N,
              z,
              f.components,
              "output",
              J.with_null_state
            ),
            time: /* @__PURE__ */ new Date(),
            event_data: t,
            trigger_id: n
          }), y.render_config && await fe(y.render_config), i({
            type: "status",
            endpoint: _,
            fn_index: d,
            stage: "complete",
            eta: y.average_duration,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          })) : i({
            type: "status",
            stage: "error",
            endpoint: _,
            fn_index: d,
            message: y.error,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          });
        }).catch((y) => {
          i({
            type: "status",
            stage: "error",
            message: y.message,
            endpoint: _,
            fn_index: d,
            queue: !1,
            time: /* @__PURE__ */ new Date()
          });
        });
      else if (O == "sse") {
        i({
          type: "status",
          stage: "pending",
          queue: !0,
          endpoint: _,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        });
        var Z = new URLSearchParams({
          fn_index: d.toString(),
          session_hash: g
        }).toString();
        let y = new URL(
          `${f.root}${R}/${Re}?${B ? B + "&" : ""}${Z}`
        );
        if (this.jwt && y.searchParams.set("__sign", this.jwt), j = this.stream(y), !j)
          return Promise.reject(
            new Error("Cannot connect to SSE endpoint: " + y.toString())
          );
        j.onmessage = async function(v) {
          const N = JSON.parse(v.data), { type: L, status: A, data: x } = be(
            N,
            he[d]
          );
          if (L === "update" && A && !T)
            i({
              type: "status",
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              ...A
            }), A.stage === "error" && (j?.close(), a());
          else if (L === "data") {
            let [C, P] = await se(
              `${f.root}${R}/queue/data`,
              {
                ...W,
                session_hash: g,
                event_id: b
              }
            );
            P !== 200 && (i({
              type: "status",
              stage: "error",
              message: M,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date()
            }), j?.close(), a());
          } else L === "complete" ? T = A : L === "log" ? i({
            type: "log",
            title: x.title,
            log: x.log,
            level: x.level,
            endpoint: _,
            duration: x.duration,
            visible: x.visible,
            fn_index: d
          }) : (L === "generating" || L === "streaming") && i({
            type: "status",
            time: /* @__PURE__ */ new Date(),
            ...A,
            stage: A?.stage,
            queue: !0,
            endpoint: _,
            fn_index: d
          });
          x && (i({
            type: "data",
            time: /* @__PURE__ */ new Date(),
            data: K(
              x.data,
              z,
              f.components,
              "output",
              J.with_null_state
            ),
            endpoint: _,
            fn_index: d,
            event_data: t,
            trigger_id: n
          }), T && (i({
            type: "status",
            time: /* @__PURE__ */ new Date(),
            ...T,
            stage: A?.stage,
            queue: !0,
            endpoint: _,
            fn_index: d
          }), j?.close(), a()));
        };
      } else if (O == "sse_v1" || O == "sse_v2" || O == "sse_v2.1" || O == "sse_v3") {
        i({
          type: "status",
          stage: "pending",
          queue: !0,
          endpoint: _,
          fn_index: d,
          time: /* @__PURE__ */ new Date()
        });
        let y = "";
        typeof window < "u" && typeof document < "u" && (y = window?.location?.hostname);
        const N = y.includes(".dev.") ? `https://moon-${y.split(".")[1]}.dev.spaces.huggingface.tech` : "https://huggingface.co";
        return (typeof window < "u" && typeof document < "u" && window.parent != window && window.supports_zerogpu_headers ? Tt("zerogpu-headers", N) : Promise.resolve(null)).then((C) => {
          const P = { ...pe, ...C || {} };
          return se(
            `${f.root}${R}/${We}?${B}`,
            {
              ...W,
              session_hash: g
            },
            P
          );
        }).then(async ([C, P]) => {
          if (C.event_id && (U = C.event_id), P === 503)
            i({
              type: "status",
              stage: "error",
              message: Oe,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              visible: !0
            });
          else if (P === 422)
            i({
              type: "status",
              stage: "error",
              message: C.detail,
              queue: !0,
              endpoint: _,
              fn_index: d,
              code: "validation_error",
              time: /* @__PURE__ */ new Date(),
              visible: !0
            }), a();
          else if (P !== 200)
            i({
              type: "status",
              stage: "error",
              broken: !1,
              message: C.detail,
              queue: !0,
              endpoint: _,
              fn_index: d,
              time: /* @__PURE__ */ new Date(),
              visible: !0
            });
          else {
            b = C.event_id, U = b;
            let me = async function(oe) {
              try {
                const { type: E, status: S, data: $, original_msg: Me } = be(
                  oe,
                  he[d]
                );
                if (E == "heartbeat")
                  return;
                if (E === "update" && S && !T)
                  i({
                    type: "status",
                    endpoint: _,
                    fn_index: d,
                    time: /* @__PURE__ */ new Date(),
                    original_msg: Me,
                    ...S
                  });
                else if (E === "complete")
                  T = S;
                else if (E == "unexpected_error" || E == "broken_connection") {
                  console.error("Unexpected error", S?.message);
                  const He = E === "broken_connection";
                  i({
                    type: "status",
                    stage: "error",
                    message: S?.message || "An Unexpected Error Occurred!",
                    queue: !0,
                    endpoint: _,
                    broken: He,
                    session_not_found: S?.session_not_found,
                    fn_index: d,
                    time: /* @__PURE__ */ new Date()
                  });
                } else if (E === "log") {
                  i({
                    type: "log",
                    title: $.title,
                    log: $.log,
                    level: $.level,
                    endpoint: _,
                    duration: $.duration,
                    visible: $.visible,
                    fn_index: d
                  });
                  return;
                } else (E === "generating" || E === "streaming") && (i({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...S,
                  stage: S?.stage,
                  queue: !0,
                  endpoint: _,
                  fn_index: d
                }), $ && z.connection !== "stream" && ["sse_v2", "sse_v2.1", "sse_v3"].includes(O) && Ht(ee, b, $));
                $ && (i({
                  type: "data",
                  time: /* @__PURE__ */ new Date(),
                  data: K(
                    $.data,
                    z,
                    f.components,
                    "output",
                    J.with_null_state
                  ),
                  endpoint: _,
                  fn_index: d
                }), $.render_config && await fe($.render_config), T && (i({
                  type: "status",
                  time: /* @__PURE__ */ new Date(),
                  ...T,
                  stage: S?.stage,
                  queue: !0,
                  endpoint: _,
                  fn_index: d
                }), a())), (S?.stage === "complete" || S?.stage === "error") && (te[b] && delete te[b], b in ee && delete ee[b]);
              } catch (E) {
                console.error("Unexpected client exception", E), i({
                  type: "status",
                  stage: "error",
                  message: "An Unexpected Error Occurred!",
                  queue: !0,
                  endpoint: _,
                  fn_index: d,
                  time: /* @__PURE__ */ new Date()
                }), ["sse_v2", "sse_v2.1", "sse_v3"].includes(O) && (le(Q, je.abort_controller), Q.open = !1, a());
              }
            };
            b in X && (X[b].forEach((oe) => me(oe)), delete X[b]), te[b] = me, Ie.add(b), Q.open || await this.open_stream();
          }
        });
      }
    });
    let Ge = !1;
    const ne = [], F = [], _e = {
      [Symbol.asyncIterator]: () => _e,
      next: c,
      throw: async (h) => (l(h), c()),
      return: async () => (a(), { value: void 0, done: !0 }),
      cancel: ze,
      send_chunk: (h) => {
        this.post_data(`${f.root}${R}/stream/${U}`, {
          ...h,
          session_hash: this.session_hash
        });
      },
      close_stream: () => {
        this.post_data(
          `${f.root}${R}/stream/${U}/close`,
          {}
        ), a();
      },
      event_id: () => U,
      wait_for_id: async () => (await Fe, b)
    };
    return _e;
  } catch (i) {
    throw console.error("Submit function encountered an error:", i), i;
  }
}
function Vt(e) {
  return {
    then: (s, t) => t(e)
  };
}
function Yt(e, s, t, n) {
  let o, r, i;
  if (typeof s == "number")
    o = s, r = e.unnamed_endpoints[o], i = n.dependencies.find((a) => a.id == s);
  else {
    const a = s.replace(/^\//, "");
    o = t[a], r = e.named_endpoints[s.trim()], i = n.dependencies.find(
      (u) => u.id == t[a]
    );
  }
  if (typeof o != "number")
    throw new Error(
      "There is no endpoint matching that name of fn_index matching that number."
    );
  return { fn_index: o, endpoint_info: r, dependency: i };
}
class V {
  app_reference;
  options;
  deep_link = null;
  config;
  api_prefix = "";
  api_info;
  api_map = {};
  session_hash = Math.random().toString(36).substring(2);
  jwt = !1;
  last_status = {};
  cookies = null;
  // streaming
  stream_status = { open: !1 };
  closed = !1;
  pending_stream_messages = {};
  pending_diff_streams = {};
  event_callbacks = {};
  unclosed_events = /* @__PURE__ */ new Set();
  heartbeat_event = null;
  abort_controller = null;
  stream_instance = null;
  current_payload;
  get_url_config(s = null) {
    if (!this.config)
      throw new Error(I);
    s === null && (s = window.location.href);
    const t = (i) => i.replace(/^\/+|\/+$/g, "");
    let n = t(new URL(this.config.root).pathname), o = t(new URL(s).pathname), r;
    return o.startsWith(n) ? r = t(o.substring(n.length)) : r = "", this.get_page_config(r);
  }
  get_page_config(s) {
    if (!this.config)
      throw new Error(I);
    let t = this.config;
    return s in t.page || (s = ""), {
      ...t,
      current_page: s,
      layout: t.page[s].layout,
      components: t.components.filter(
        (n) => t.page[s].components.includes(n.id)
      ),
      dependencies: this.config.dependencies.filter(
        (n) => t.page[s].dependencies.includes(n.id)
      )
    };
  }
  fetch(s, t) {
    const n = new Headers(t?.headers || {});
    return this && this.cookies && n.append("Cookie", this.cookies), this && this.options.headers && new Headers(this.options.headers).forEach((r, i) => {
      n.append(i, r);
    }), fetch(s, { ...t, headers: n });
  }
  stream(s) {
    const t = new Headers();
    return this && this.cookies && t.append("Cookie", this.cookies), this && this.options.headers && new Headers(this.options.headers).forEach((o, r) => {
      t.append(r, o);
    }), this && this.options.token && t.append("Authorization", `Bearer ${this.options.token}`), this.abort_controller = new AbortController(), this.stream_instance = Zt(s.toString(), {
      credentials: "include",
      headers: t,
      signal: this.abort_controller.signal
    }), this.stream_instance;
  }
  view_api;
  upload_files;
  upload;
  handle_blob;
  post_data;
  submit;
  predict;
  open_stream;
  resolve_config;
  resolve_cookies;
  constructor(s, t = { events: ["data"] }) {
    this.app_reference = s, this.deep_link = t.query_params?.deep_link || null, t.events || (t.events = ["data"]), this.options = t, this.current_payload = {}, this.view_api = yt.bind(this), this.upload_files = bt.bind(this), this.handle_blob = At.bind(this), this.post_data = Dt.bind(this), this.submit = Kt.bind(this), this.predict = Nt.bind(this), this.open_stream = Mt.bind(this), this.resolve_config = pt.bind(this), this.resolve_cookies = ht.bind(this), this.upload = kt.bind(this), this.fetch = this.fetch.bind(this), this.handle_space_success = this.handle_space_success.bind(this), this.stream = this.stream.bind(this);
  }
  async init() {
    this.options.auth && await this.resolve_cookies(), await this._resolve_config().then(
      ({ config: s }) => this._resolve_heartbeat(s)
    ), this.api_info = await this.view_api(), this.api_map = lt(this.config?.dependencies || []);
  }
  async _resolve_heartbeat(s) {
    if (s && (this.config = s, this.api_prefix = s.api_prefix || "", this.config && this.config.connect_heartbeat && this.config.space_id && this.options.token && (this.jwt = await ye(
      this.config.space_id,
      this.options.token,
      this.cookies
    ))), s.space_id && this.options.token && (this.jwt = await ye(s.space_id, this.options.token)), this.config && this.config.connect_heartbeat) {
      const t = new URL(
        `${this.config.root}${this.api_prefix}/${Qe}/${this.session_hash}`
      );
      this.jwt && t.searchParams.set("__sign", this.jwt), this.heartbeat_event || (this.heartbeat_event = this.stream(t));
    }
  }
  static async connect(s, t = {
    events: ["data"]
  }) {
    const n = new this(s, t);
    return t.session_hash && (n.session_hash = t.session_hash), await n.init(), n;
  }
  async reconnect() {
    const s = new URL(
      `${this.config.root}${this.api_prefix}/${st}`
    );
    let t;
    try {
      const n = await this.fetch(s);
      if (!n.ok)
        throw new Error();
      t = (await n.json()).app_id;
    } catch {
      return "broken";
    }
    return t !== this.config.app_id ? "changed" : "connected";
  }
  close() {
    this.closed = !0, le(this.stream_status, this.abort_controller);
  }
  set_current_payload(s) {
    this.current_payload = s;
  }
  static async duplicate(s, t = {
    events: ["data"]
  }) {
    return jt(s, t);
  }
  async _resolve_config() {
    const { http_protocol: s, host: t, space_id: n } = await ue(
      this.app_reference,
      this.options.token
    ), { status_callback: o } = this.options;
    n && o && await Pe(n, o);
    let r;
    try {
      let i = `${s}//${t}`;
      if (r = await this.resolve_config(i), !r)
        throw new Error(I);
      return this.config_success(r);
    } catch (i) {
      if (n && o)
        G(
          n,
          ce.test(n) ? "space_name" : "subdomain",
          this.handle_space_success
        );
      else
        throw o && o({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), Error(i);
    }
  }
  async config_success(s) {
    if (this.config = s, this.api_prefix = s.api_prefix || "", this.config.auth_required)
      return this.prepare_return_obj();
    try {
      this.api_info = await this.view_api();
    } catch (t) {
      console.error(ot + t.message);
    }
    return this.prepare_return_obj();
  }
  async handle_space_success(s) {
    if (!this)
      throw new Error(I);
    const { status_callback: t } = this.options;
    if (t && t(s), s.status === "running")
      try {
        if (this.config = await this._resolve_config(), this.api_prefix = this?.config?.api_prefix || "", !this.config)
          throw new Error(I);
        return await this.config_success(this.config);
      } catch (n) {
        throw t && t({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), n;
      }
  }
  async component_server(s, t, n) {
    if (!this.config)
      throw new Error(I);
    const o = {}, { token: r } = this.options, { session_hash: i } = this;
    r && (o.Authorization = `Bearer ${this.options.token}`);
    let a, u = this.config.components.find(
      (p) => p.id === s
    );
    u?.props?.root_url ? a = u.props.root_url : a = this.config.root;
    let l;
    if ("binary" in n) {
      l = new FormData();
      for (const p in n.data)
        p !== "binary" && l.append(p, n.data[p]);
      l.set("component_id", s.toString()), l.set("fn_name", t), l.set("session_hash", i);
    } else
      l = JSON.stringify({
        data: n,
        component_id: s,
        fn_name: t,
        session_hash: i
      }), o["Content-Type"] = "application/json";
    r && (o.Authorization = `Bearer ${r}`);
    try {
      const p = await this.fetch(
        `${a}${this.api_prefix}/${Xe}/`,
        {
          method: "POST",
          body: l,
          headers: o,
          credentials: "include"
        }
      );
      if (!p.ok)
        throw new Error(
          "Could not connect to component server: " + p.statusText
        );
      return await p.json();
    } catch (p) {
      console.warn(p);
    }
  }
  set_cookies(s) {
    this.cookies = Ce(s).join("; ");
  }
  prepare_return_obj() {
    return {
      config: this.config,
      predict: this.predict,
      submit: this.submit,
      view_api: this.view_api,
      component_server: this.component_server
    };
  }
}
async function ts(e, s = {
  events: ["data"]
}) {
  return await V.connect(e, s);
}
async function ss(e, s) {
  return await V.duplicate(e, s);
}
export {
  V as Client,
  Y as FileData,
  at as MISSING_CREDENTIALS_MSG,
  ts as client,
  ss as duplicate,
  es as handle_file,
  Nt as predict,
  Xt as prepare_files,
  Kt as submit,
  kt as upload,
  bt as upload_files
};
